// table to hold all settings for this wizard
PluginSettings <- {
    Type = 0 // cbToolPlugin

    Name = wxT_2("")
    Title = wxT_2("")
    Version = wxT_2("")
    Description = wxT_2("")
    Author = wxT_2("")
    Email = wxT_2("")
    Website = wxT_2("")
    ThanksTo = wxT_2("")

    HasConfig = false
    HasMenu = false
    HasModuleMenu = false
    HasToolbar = false
}
WxVersion <- 1; // 0 - wx 2.6, 1 - wx 2.8

// -----------------------------------------------------------------------------
// init wizard
function BeginWizard()
{
    local wiz_type = Wizard.GetWizardType();

    local intro_msg = wxT_2("Welcome to the new Code::Blocks plugin wizard!\n" +
                         "This wizard will guide you to create a new Code::Blocks plugin.\n\n");
    if (PLATFORM == PLATFORM_MSW)
    {
        intro_msg += wxT_2("\nVERY IMPORTANT NOTE:\n\n" +
                        "Code::Blocks is built with the GNU GCC compiler and links to\n" +
                        "the monolithic unicode wxWidgets DLL.\n" +
                        "This means that you must have exactly this setup to be able to\n" +
                        "build the generated plugin.\n" +
                        "You must also have defined two global variables:\n" +
                        "   1. $(#cb) pointing to Code::Blocks base dir (where CodeBlocks.cbp is)\n" +
                        "   2. $(#wx) pointing to wxWidgets base directory\n\n\n");
    }
    intro_msg += wxT_2("When you 're ready to proceed, please click \"Next\"...");

    Wizard.AddInfoPage(wxT_2("PluginIntro"), intro_msg);
    Wizard.AddProjectPathPage();
    Wizard.AddPage(wxT_2("PluginOptions"));
    Wizard.AddPage(wxT_2("PluginInfo"));
    Wizard.AddGenericSingleChoiceListPage(wxT_2("wxVersionPage"), wxT_2("Please select the wxWidgets version you want to use."), wxT_2("wxWidgets 2.6.x;wxWidgets 2.8.x"), WxVersion); // select wxwidgets version
    Wizard.AddCompilerPage(wxT_2(""), wxT_2("gcc*"), true, false);
}

// -----------------------------------------------------------------------------
// entering plugin options page
function OnEnter_PluginOptions(fwd)
{
    // update options state
    OnClick_cmbPluginType();
}

// -----------------------------------------------------------------------------
// enable/disable available options based on selected plugin type
function OnClick_cmbPluginType()
{
    PluginSettings.Type = Wizard.GetComboboxSelection(wxT_2("cmbPluginType"));

    local isTool = PluginSettings.Type == 1;
    local isMime = PluginSettings.Type == 2;
    local isWizard = PluginSettings.Type == 3;
    Wizard.EnableWindow(wxT_2("chkHasConfig"), !isWizard);
    Wizard.EnableWindow(wxT_2("chkHasMenu"), !isTool && !isMime && !isWizard);
    Wizard.EnableWindow(wxT_2("chkHasModuleMenu"), !isTool && !isMime && !isWizard);
    Wizard.EnableWindow(wxT_2("chkHasToolbar"), !isTool && !isMime && !isWizard);
}

// -----------------------------------------------------------------------------
// leaving plugin options page, validate entered values
function OnLeave_PluginOptions(fwd)
{
    if (fwd)
    {
        // read text values entered
        PluginSettings.Name = Wizard.GetTextControlValue(wxT_2("txtPluginName"));
        PluginSettings.Type = Wizard.GetComboboxSelection(wxT_2("cmbPluginType"));
        PluginSettings.HasConfig = Wizard.IsCheckboxChecked(wxT_2("chkHasConfig"));
        PluginSettings.HasMenu = Wizard.IsCheckboxChecked(wxT_2("chkHasMenu"));
        PluginSettings.HasModuleMenu = Wizard.IsCheckboxChecked(wxT_2("chkHasModuleMenu"));
        PluginSettings.HasToolbar = Wizard.IsCheckboxChecked(wxT_2("chkHasToolbar"));

        // check that essentials were filled in
        if (PluginSettings.Name.IsEmpty())
        {
            ShowWarning(wxT_2("You have to enter the plugin's name before you can proceed..."));
            return false;
        }
    }
    return true;
}

// -----------------------------------------------------------------------------
// entering plugin info page, set some default values
function OnEnter_PluginInfo(fwd)
{
    if (fwd)
    {
        // set the title same as the project title
        if (Wizard.GetTextControlValue(wxT_2("txtTitle")).IsEmpty())
            Wizard.SetTextControlValue(wxT_2("txtTitle"), Wizard.GetProjectTitle());
        if (Wizard.GetTextControlValue(wxT_2("txtVersion")).IsEmpty())
            Wizard.SetTextControlValue(wxT_2("txtVersion"), wxT_2("0.1"));

        // load config
        Wizard.SetTextControlValue(wxT_2("txtAuthor"), GetConfigManager().Read(wxT_2("/cb_plugin_wizard/author"), wxT_2("")));
        Wizard.SetTextControlValue(wxT_2("txtEmail"), GetConfigManager().Read(wxT_2("/cb_plugin_wizard/email"), wxT_2("")));
        Wizard.SetTextControlValue(wxT_2("txtWebsite"), GetConfigManager().Read(wxT_2("/cb_plugin_wizard/website"), wxT_2("")));
    }
}

// -----------------------------------------------------------------------------
// leaving plugin info page, validate entered values
function OnLeave_PluginInfo(fwd)
{
    if (fwd)
    {
        // read text values entered
        PluginSettings.Title = Wizard.GetTextControlValue(wxT_2("txtTitle"));
        PluginSettings.Version = Wizard.GetTextControlValue(wxT_2("txtVersion"));
        PluginSettings.Description = Wizard.GetTextControlValue(wxT_2("txtDescription"));
        PluginSettings.Author = Wizard.GetTextControlValue(wxT_2("txtAuthor"));
        PluginSettings.Email = Wizard.GetTextControlValue(wxT_2("txtEmail"));
        PluginSettings.Website = Wizard.GetTextControlValue(wxT_2("txtWebsite"));
        PluginSettings.ThanksTo = Wizard.GetTextControlValue(wxT_2("txtThanksTo"));

        // check that essentials were filled in
        if (PluginSettings.Name.IsEmpty() ||
            PluginSettings.Version.IsEmpty())
        {
            ShowWarning(wxT_2("You have to fill the Title and Version fields before you can proceed..."));
            return false;
        }
        PluginSettings.Name = GetFixedProjectName(PluginSettings.Name);
    }

    // save config
    GetConfigManager().Write(wxT_2("/cb_plugin_wizard/author"), PluginSettings.Author);
    GetConfigManager().Write(wxT_2("/cb_plugin_wizard/email"), PluginSettings.Email);
    GetConfigManager().Write(wxT_2("/cb_plugin_wizard/website"), PluginSettings.Website);
    return true;
}

////////////////////////////////////////////////////////////////////////////////
// wxWidgets' version page
////////////////////////////////////////////////////////////////////////////////

function OnEnter_wxVersionPage(fwd)
{
    if (fwd)
    {
        WxVersion = Wizard.GetListboxSelection(wxT_2("GenericChoiceList"));
    }
    return true;
}

function OnLeave_wxVersionPage(fwd)
{
    if (fwd)
    {
        WxVersion = Wizard.GetListboxSelection(wxT_2("GenericChoiceList"));
    }
    return true;
}

// -----------------------------------------------------------------------------
// each time, return a string of the form "filename.ext;contents"
// you can change the return string based on <file_index>
// return an empty string to denote that no more files are to be generated
function GetGeneratedFile(file_index)
{
    switch (file_index)
    {
        // header file
        case 0: return PluginSettings.Name + DOT_EXT_H + wxT_2(";") + GenerateHeader();
        // source file
        case 1: return PluginSettings.Name + DOT_EXT_CPP + wxT_2(";") + GenerateSource();
        // manifest
        case 2: return wxT_2("manifest") + DOT_EXT_XML + wxT_2(";") + GenerateManifest();
    }
    return wxT_2(""); // no more generated files
}

// -----------------------------------------------------------------------------
// setup the project options
function SetupProject(project)
{
    local target = project.GetBuildTarget(wxT_2("default"));
    if (IsNull(target))
        target = project.AddBuildTarget(wxT_2("default"));
    SetupTarget(target, true);

    return true;
}

function SetupTarget(target,is_debug)
{
    if (IsNull(target))
        return false;

    target.SetTargetType(ttDynamicLib);
    target.SetOutputFilename(PluginSettings.Name);
    target.SetCreateDefFile(false);
    target.SetCreateStaticLib(false);

    if (PLATFORM == PLATFORM_MSW)
    {
        target.AddCompilerOption(wxT_2("-DBUILDING_PLUGIN"));
        target.AddCompilerOption(wxT_2("-DHAVE_W32API_H"));
        target.AddCompilerOption(wxT_2("-D__WXMSW__"));
        target.AddCompilerOption(wxT_2("-DWXUSINGDLL"));
        target.AddCompilerOption(wxT_2("-DcbDEBUG"));
        target.AddCompilerOption(wxT_2("-DCB_PRECOMP"));
        target.AddCompilerOption(wxT_2("-DWX_PRECOMP"));
        target.AddCompilerOption(wxT_2("-DwxUSE_UNICODE"));
        target.AddCompilerOption(wxT_2("-pipe"));
        target.AddCompilerOption(wxT_2("-mthreads"));
        target.AddCompilerOption(wxT_2("-fmessage-length=0"));
        target.AddCompilerOption(wxT_2("-fexceptions"));
        target.AddCompilerOption(wxT_2("-Winvalid-pch"));

        target.AddLinkerOption(wxT_2("-mthreads"));

        target.AddIncludeDir(wxT_2("$(#cb)\\include"));
        target.AddIncludeDir(wxT_2("$(#cb)\\sdk\\wxscintilla\\include"));
        target.AddIncludeDir(wxT_2("$(#wx.include)"));
        target.AddIncludeDir(wxT_2("$(#wx.lib)\\gcc_dll\\mswu"));

        target.AddLinkLib(wxT_2("codeblocks"));
        if (WxVersion == 0)
            target.AddLinkLib(wxT_2("wxmsw26u"));
        else
            target.AddLinkLib(wxT_2("wxmsw28u"));

        target.AddLibDir(wxT_2("$(#cb)\\devel"));
        target.AddLibDir(wxT_2("$(#wx.lib)\\gcc_dll"));

        target.SetHostApplication(wxT_2("$(#cb)\\devel\\codeblocks") + DOT_EXT_EXECUTABLE);
    }
    else
    {
        target.AddCompilerOption(wxT_2("`pkg-config --cflags codeblocks`"));
        target.AddCompilerOption(wxT_2("`wx-config --cflags`"));
        target.AddCompilerOption(wxT_2("-ansi"));
        target.AddCompilerOption(wxT_2("-fPIC"));

        target.AddLinkerOption(wxT_2("`pkg-config --libs codeblocks`"));
        target.AddLinkerOption(wxT_2("`wx-config --libs`"));

        target.SetHostApplication(wxT_2("codeblocks") + DOT_EXT_EXECUTABLE);
    }

    // create plugin resources
    target.AddCommandsAfterBuild(wxT_2("zip -j9 ") +
                                PluginSettings.Name + wxT_2(".zip manifest") + DOT_EXT_XML);
    // create plugin distribution file
    target.AddCommandsAfterBuild(wxT_2("zip -j9 ") + PluginSettings.Name + wxT_2(".cbplugin ") +
                                target.GetOutputFilename() + wxT_2(" ") +
                                PluginSettings.Name + wxT_2(".zip"));

    if (is_debug)
        DebugSymbolsOn(target, Wizard.GetCompilerID());

    return true;
}



////////////////////////////////////////////////////////////////////////////////
//
// locally defined functions below
//
////////////////////////////////////////////////////////////////////////////////



// -----------------------------------------------------------------------------
// return the header contents string
function GenerateHeader()
{
    local path = Wizard.FindTemplateFile(GetTemplateFile(DOT_EXT_H));
    local buffer = IO.ReadFileContents(path);

    // create header guard word
    local guard = PluginSettings.Name + DOT_EXT_H + wxT_2("_INCLUDED");
    guard.MakeUpper();
    guard.Replace(wxT_2(" "), wxT_2("_"));
    guard.Replace(wxT_2("."), wxT_2("_"));
    buffer.Replace(wxT_2("[GUARD_WORD]"), guard);

    return SubstituteMacros(buffer);
}

// -----------------------------------------------------------------------------
// return the implementation contents string
function GenerateSource()
{
    local path = Wizard.FindTemplateFile(GetTemplateFile(DOT_EXT_CPP));
    local buffer = IO.ReadFileContents(path);

    return SubstituteMacros(buffer);
}

// -----------------------------------------------------------------------------
// return the manifest contents string
function GenerateManifest()
{
    local path = Wizard.FindTemplateFile(wxT_2("plugins/templates/manifest_template.xml"));
    local buffer = IO.ReadFileContents(path);

    return SubstituteMacros(buffer);
}

// -----------------------------------------------------------------------------
// return the template's filename, appending <dot_ext> as an extension (must include the dot)
function GetTemplateFile(dot_ext)
{
    local template_file = wxT_2("");
    switch (PluginSettings.Type)
    {
        // generic plugin
        case 0: template_file = wxT_2("plugins/templates/generic_template") + dot_ext; break;
        // tool plugin
        case 1: template_file = wxT_2("plugins/templates/tool_template") + dot_ext; break;
        // mime plugin
        case 2: template_file = wxT_2("plugins/templates/mime_template") + dot_ext; break;
        // wizard plugin
        case 3: template_file = wxT_2("plugins/templates/wizard_template") + dot_ext; break;

        default: break; // error
    }
    return template_file;
}

// -----------------------------------------------------------------------------
// substitute all plugin macros in <buffer>
function SubstituteMacros(buffer)
{
    // handle [IF] / [ENDIF] pairs
    buffer = HandleDirective(buffer, wxT_2("HAS_CONFIGURE"), PluginSettings.HasConfig);
    buffer = HandleDirective(buffer, wxT_2("HAS_MENU"), PluginSettings.HasMenu);
    buffer = HandleDirective(buffer, wxT_2("HAS_MODULE_MENU"), PluginSettings.HasModuleMenu);
    buffer = HandleDirective(buffer, wxT_2("HAS_TOOLBAR"), PluginSettings.HasToolbar);
    buffer = HandleDirective(buffer, wxT_2("NEED_EVENTS"), PluginSettings.HasMenu ||
                                                        PluginSettings.HasModuleMenu ||
                                                        PluginSettings.HasToolbar);

    // macros substitution
    buffer.Replace(wxT_2("[PLUGIN_SDK_VERSION_MAJOR]"), wxT_2("") + PLUGIN_SDK_VERSION_MAJOR);
    buffer.Replace(wxT_2("[PLUGIN_SDK_VERSION_MINOR]"), wxT_2("") + PLUGIN_SDK_VERSION_MINOR);
    buffer.Replace(wxT_2("[PLUGIN_SDK_VERSION_RELEASE]"), wxT_2("") + PLUGIN_SDK_VERSION_RELEASE);
    buffer.Replace(wxT_2("[PLUGIN_NAME]"), PluginSettings.Name);
    buffer.Replace(wxT_2("[PLUGIN_TITLE]"), PluginSettings.Title);
    buffer.Replace(wxT_2("[PLUGIN_VERSION]"), PluginSettings.Version);
    buffer.Replace(wxT_2("[PLUGIN_DESCRIPTION]"), PluginSettings.Description);
    buffer.Replace(wxT_2("[PROJECT_NAME]"), Wizard.GetProjectName());
    buffer.Replace(wxT_2("[AUTHOR_NAME]"), PluginSettings.Author);
    buffer.Replace(wxT_2("[AUTHOR_EMAIL]"), PluginSettings.Email);
    buffer.Replace(wxT_2("[AUTHOR_WWW]"), PluginSettings.Website);
    buffer.Replace(wxT_2("[THANKS_TO]"), PluginSettings.ThanksTo);
    buffer.Replace(wxT_2("[HEADER_FILENAME]"), PluginSettings.Name + DOT_EXT_H);
    buffer.Replace(wxT_2("[NOW]"), ReplaceMacros(wxT_2("$(TODAY)"), false));

    return buffer;
}

// -----------------------------------------------------------------------------
// if <enabled> is true, removes the [IF <directive>] and [ENDIF <directive>]
// macros.
// if <enabled> is false, removes everything enclosed by the [IF <directive>]
// and [ENDIF <directive>] macros (including them).
function HandleDirective(buffer, directive, enabled)
{
    local dir_if = wxT_2("[IF ") + directive + wxT_2("]");
    local dir_endif = wxT_2("[ENDIF ") + directive + wxT_2("]");

    local findStart = buffer.Find(dir_if);
    if (findStart == -1)
        return buffer;

    local findEnd = buffer.Find(dir_endif);
    if (findEnd == -1 || findEnd <= findStart)
        return buffer;

    // look for [ELSE]
    local block = buffer.Mid(findStart, findEnd - findStart);
    local findElse = block.Find(wxT_2("[ELSE]")); // findElse is in "local scope", i.e. offset from findStart

    if (!enabled)
    {
        if (findElse == -1)
        {
            // remove whole section
            buffer.Remove(findStart, (findEnd - findStart) + dir_endif.Length());
        }
        else
        {
            // remove [ENDIF]
            buffer.Remove(findEnd, dir_endif.Length());
            // remove from [IF] to [ELSE] (including)
            buffer.Remove(findStart, findElse + 6); // 6 is the [ELSE] size
        }
    }
    else
    {
        if (findElse == -1)
        {
            // just remove the directives
            // we must remove the [ENDIF] first because if we removed the [IF] it would
            // render the findEnd index invalid!
            buffer.Remove(findEnd, dir_endif.Length());
            buffer.Remove(findStart, dir_if.Length());
        }
        else
        {
            // remove from [ELSE] to [ENDIF]
            local start = findStart + findElse;
            buffer.Remove(start, (findEnd - start) + dir_endif.Length());
            // remove from [IF]
            buffer.Remove(findStart, dir_if.Length());
        }
    }

    return buffer;
}
